<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Python 面试题 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Q: 简述解释型语言和编译型语言？计算机是不能理解高级语言的，更不能直接执行高级语言，它只能直接理解机器语言，所以使用任何高级语言编写的程序若想被计算机运行，都必须将其转换成计算机语言，也就是机器码。 转换的方式有两种：编译、解释。由此高级语言也分为编译型语言和解释型语言。主要区别在于，前者源程序编译后即可在该平台运行，后者是在运行期间才编译。所以前者运行速度快，后者跨平台性好。   编译型语言和">
<meta property="og:type" content="article">
<meta property="og:title" content="Python 面试题">
<meta property="og:url" content="http://example.com/2020/09/28/Python%20%E9%9D%A2%E8%AF%95%E9%A2%98/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="Q: 简述解释型语言和编译型语言？计算机是不能理解高级语言的，更不能直接执行高级语言，它只能直接理解机器语言，所以使用任何高级语言编写的程序若想被计算机运行，都必须将其转换成计算机语言，也就是机器码。 转换的方式有两种：编译、解释。由此高级语言也分为编译型语言和解释型语言。主要区别在于，前者源程序编译后即可在该平台运行，后者是在运行期间才编译。所以前者运行速度快，后者跨平台性好。   编译型语言和">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/Users/stephent/stphentututu/Python_case_interview/markdown_pic/Snipaste_2020-09-28_10-47-47.png">
<meta property="og:image" content="http://example.com/Users/stephent/stphentututu/Python_case_interview/markdown_pic/Snipaste_2020-09-29_13-17-47.png">
<meta property="og:image" content="http://example.com/Users/stephent/stphentututu/Python_case_interview/markdown_pic/Snipaste_2020-09-29_13-35-13.png">
<meta property="og:image" content="http://example.com/Users/stephent/stphentututu/Python_case_interview/markdown_pic/Snipaste_2020-09-29_13-44-43.png">
<meta property="og:image" content="http://example.com/Users/stephent/stphentututu/Python_case_interview/markdown_pic/Snipaste_2020-09-29_13-45-41.png">
<meta property="og:image" content="http://example.com/Users/stephent/stphentututu/Python_case_interview/markdown_pic/Snipaste_2020-09-29_14-39-19.png">
<meta property="og:image" content="http://example.com/Users/stephent/stphentututu/Python_case_interview/markdown_pic/Snipaste_2020-09-29_14-40-49.png">
<meta property="og:image" content="http://example.com/Users/stephent/stphentututu/Python_case_interview/markdown_pic/Snipaste_2020-09-29_14-48-52.png">
<meta property="og:image" content="http://example.com/Users/stephent/stphentututu/Python_case_interview/markdown_pic/Snipaste_2020-10-01_00-22-23.png">
<meta property="og:image" content="http://example.com/Users/stephent/stphentututu/Python_case_interview/markdown_pic/Snipaste_2020-10-01_00-26-21.png">
<meta property="og:image" content="http://example.com/Users/stephent/stphentututu/Python_case_interview/markdown_pic/Snipaste_2020-10-01_01-39-06.png">
<meta property="og:image" content="http://example.com/Users/stephent/stphentututu/Python_case_interview/markdown_pic/Snipaste_2020-10-01_21-58-22.png">
<meta property="og:image" content="http://example.com/Users/stephent/stphentututu/Python_case_interview/markdown_pic/Snipaste_2020-10-01_22-00-37.png">
<meta property="og:image" content="http://example.com/Users/stephent/stphentututu/Python_case_interview/markdown_pic/Snipaste_2020-10-01_22-05-04.png">
<meta property="og:image" content="http://example.com/Users/stephent/stphentututu/Python_case_interview/markdown_pic/Snipaste_2020-10-01_22-51-51.png">
<meta property="og:image" content="http://example.com/Users/stephent/stphentututu/Python_case_interview/markdown_pic/Snipaste_2020-10-01_22-53-50.png">
<meta property="og:image" content="http://example.com/Users/stephent/stphentututu/Python_case_interview/markdown_pic/Snipaste_2020-10-01_22-54-44.png">
<meta property="og:image" content="http://example.com/Users/stephent/stphentututu/Python_case_interview/markdown_pic/Snipaste_2020-10-01_23-10-40.png">
<meta property="og:image" content="http://example.com/Users/stephent/stphentututu/Python_case_interview/markdown_pic/Snipaste_2020-10-01_23-12-23.png">
<meta property="og:image" content="http://example.com/Users/stephent/stphentututu/Python_case_interview/markdown_pic/Snipaste_2020-10-01_23-19-56.png">
<meta property="article:published_time" content="2020-09-28T02:20:55.916Z">
<meta property="article:modified_time" content="2020-10-18T06:46:51.470Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/Users/stephent/stphentututu/Python_case_interview/markdown_pic/Snipaste_2020-09-28_10-47-47.png">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-Python 面试题" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/09/28/Python%20%E9%9D%A2%E8%AF%95%E9%A2%98/" class="article-date">
  <time datetime="2020-09-28T02:20:55.916Z" itemprop="datePublished">2020-09-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Python 面试题
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="Q-简述解释型语言和编译型语言？"><a href="#Q-简述解释型语言和编译型语言？" class="headerlink" title="Q: 简述解释型语言和编译型语言？"></a>Q: 简述解释型语言和编译型语言？</h3><p>计算机是不能理解高级语言的，更不能直接执行高级语言，它只能直接理解机器语言，所以使用任何高级语言编写的程序若想被计算机运行，都必须将其转换成计算机语言，也就是机器码。</p>
<p>转换的方式有两种：<br>编译、解释。由此高级语言也分为编译型语言和解释型语言。主要区别在于，前者源程序编译后即可在该平台运行，后者是在运行期间才编译。所以前者运行速度快，后者跨平台性好。</p>
<div align= center >
<img src="/Users/stephent/stphentututu/Python_case_interview/markdown_pic/Snipaste_2020-09-28_10-47-47.png" width="40%" alt="图片"/>
<center style="font-size:14px;color:#C0C0C0">编译型语言和解释型语言的执行流程</center>
</br>
</div>

<ul>
<li><p>解释型语言：定义：<br>使用专门的解释器对源程序逐行解释成特定平台的机器码并立即执行。是代码在执行时才被解释器一行行动态翻译和执行，而不是在执行之前就完成翻译。<br>特点：<br>解释型语言不需要事先编译，其直接将源代码解释成机器码并立即执行，所以只要某一平台提供了相应的解释器即可运行该程序。</br><br>总结:</br><br>  （1）解释型语言每次运行都需要将源代码解释称机器码并执行，效率较低；</br><br>  （2）只要平台提供相应的解释器，就可以运行源代码，所以可以方便源程序移植；</br><br>  （3）Python等属于解释型语言</br></p>
</li>
<li><p>编译型语言：定义：<br>使用专门的编译器，针对特定的平台，将高级语言源代码一次性的编译成可被该平台硬件执行的机器码，并包装成该平台所能识别的可执行性程序的格式。<br>特点：<br>在编译型语言写的程序执行之前，需要一个专门的编译过程，把源代码编译成机器语言的文件，如exe格式的文件，以后要再运行时，直接使用编译结果即可，如直接运行exe文件。因为只需编译一次，以后运行时不需要编译，所以编译型语言执行效率高。</p>
</li>
</ul>
<p>Python 属于典型的解释型语言，所以运行 Python 程序需要解释器的支持，只要你在不同的平台安装了不同的解释器，你的代码就可以随时运行，不用担心任何兼容性问题，真正的“一次编写，到处运行”。</p>
<h3 id="Q-Python解释器的种类和特点？"><a href="#Q-Python解释器的种类和特点？" class="headerlink" title="Q: Python解释器的种类和特点？"></a>Q: Python解释器的种类和特点？</h3><ol>
<li>CPython：官方解释器，C语言开发，在命令行下运行python就是启动CPython解释器。是使用最广的解释器。</li>
<li>IPython：基于CPython之上的一个交互式解释器，只是在交互方式上有所增强，但是执行Python代码的功能和CPython是完全一样的。CPython用&gt;&gt;&gt;作为提示符，而IPython用In [序号]:作为提示符。</li>
<li>PyPy：Python写的解释器，目标是执行速度，采用JIT技术，对Python代码进行动态编译（注意不是解释）<br>可以显著提高Python代码的执行速度。</li>
<li>JPython：Java写的Python解释器，可直接把Python代码编译成Java字节码执行。</li>
<li>IronPython：类似JPython，运行在微软 .net平台上的解释器，可直接把Python代码编译成.Net的字节码。</li>
</ol>
<h3 id="Q-请至少列举5个-PEP8-规范（越多越好）"><a href="#Q-请至少列举5个-PEP8-规范（越多越好）" class="headerlink" title="Q: 请至少列举5个 PEP8 规范（越多越好）"></a>Q: 请至少列举5个 PEP8 规范（越多越好）</h3><ol>
<li>缩进：每一级缩进使用4个空格</li>
<li>行的最大长度：所有行限制的最大字符数为79</li>
<li>空行：顶层函数和类的定义，前后用两个空行隔开；类里的方法定义用一个空行隔开</li>
<li>Imports 导入：入通常在分开的行，导入总是位于文件的顶部，在模块注释和文档字符串之后，在模块的全局变量与常量之前</li>
<li>约定俗称的命名：类名一般使用首字母大写的约定</li>
<li>函数命名：函数名应该小写，如果想提高可读性可以用下划线分隔</li>
</ol>
<h3 id="Q-ascii、unicode、utf-8、gbk-区别"><a href="#Q-ascii、unicode、utf-8、gbk-区别" class="headerlink" title="Q: ascii、unicode、utf-8、gbk 区别"></a>Q: ascii、unicode、utf-8、gbk 区别</h3><blockquote>
<p>ascii </br><br>美国制定了一套字符编码，对英语字符与二进制位之间的关系，做了统一规定。这被称为 ASCII 码</br><br>unicode </br><br>一套编码方案来解决所有国家的编码问题,注意Unicode不是一个新的编码规则，二是一套字符集（为每一个「字符」分配一个唯一的 ID（学名为码位 / 码点 / Code Point）），可以将Unicode理解为一本世界编码的字典</br><br>UTF-8编码</br><br> 由于Unicode比较浪费网络带宽和硬盘，因此为了解决这个问题，就在Unicode的基础上，定义了一套编码规则（将「码位」转换为字节序列的规则（编码/解码 可以理解为 加密/解密 的过程）），这个新的编码规则就是UTF-8，采用1-4个字符进行传输和存储数据</br><br>GBK编码</br><br>当字符小于127位时，与ASCII的字符相同，但当两个大于127的字符连接在一起时，就代表一个汉字，第一个字节称为高字节（从0xA1-0xF7）,第二个字节为低字节（从0xA1-0xFE）,这样大约可以组合7000多个简体汉字。这个规则叫做<strong>GB2312</strong></br><br>由于中国汉字很多，有些字无法表示，于是重新定义了规则：不在要求低字节一定是127之后的编码，只要第一个字节是大于127，就固定表示这是一个汉字的开始，不管后面跟的是不是扩展字符集里的内容。这种扩展之后的编码方案称之为GBK标，包括了GB2312的所有内容，同时新增了近20000个新的汉字（包括繁体字）和符号.</p>
</blockquote>
<ul>
<li>UTF-8和Unicode的关系</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Unicode符号范围     |        UTF<span class="number">-8</span>编码方式</span><br><span class="line"> (十六进制)         |         （二进制）</span><br><span class="line">----------------------+---------------------------------------------</span><br><span class="line"><span class="number">0000</span> <span class="number">0000</span><span class="number">-0000</span> <span class="number">007</span>F | <span class="number">0</span>xxxxxxx</span><br><span class="line"><span class="number">0000</span> <span class="number">0080</span><span class="number">-0000</span> <span class="number">07</span>FF | <span class="number">110</span>xxxxx <span class="number">10</span>xxxxxx</span><br><span class="line"><span class="number">0000</span> <span class="number">0800</span><span class="number">-0000</span> FFFF | <span class="number">1110</span>xxxx <span class="number">10</span>xxxxxx <span class="number">10</span>xxxxxx</span><br><span class="line"><span class="number">0001</span> <span class="number">0000</span><span class="number">-0010</span> FFFF | <span class="number">11110</span>xxx <span class="number">10</span>xxxxxx <span class="number">10</span>xxxxxx <span class="number">10</span>xxxxxx</span><br></pre></td></tr></table></figure>

<h3 id="Q-字节码和机器码的区别"><a href="#Q-字节码和机器码的区别" class="headerlink" title="Q: 字节码和机器码的区别"></a>Q: 字节码和机器码的区别</h3><ul>
<li>机器码(machine code)，学名机器语言指令，有时也被称为原生码（Native Code），是电脑的CPU可直接解读的数据。通常意义上来理解的话，机器码就是计算机可以直接执行，并且执行速度最快的代码。</li>
<li>字节码（Bytecode）是一种包含执行程序、由一序列 op 代码/数据对 组成的二进制文件。<strong>字节码是一种中间码</strong>，它比机器码更抽象，需要直译器转译后才能成为机器码的中间代码。<strong>字节码的典型应用为Java bytecode</strong>。字节码是一种中间状态（中间码）的二进制代码（文件），需要直译器转译后才能成为机器码。</li>
</ul>
<h3 id="Q-三元运算规则以及应用场景"><a href="#Q-三元运算规则以及应用场景" class="headerlink" title="Q: 三元运算规则以及应用场景"></a>Q: 三元运算规则以及应用场景</h3><p>三元运算符就是在赋值变量的时候，可以直接加判断，然后赋值<br><br>三元运算符的功能与’if….else’流程语句一致，它在一行中书写，代码非常精炼，执行效率更高</p>
<p><code>格式：[on_true] if [expression] else [on_false]</code><br><br>        <code>res = 值1 if 条件 else 值2</code></p>
<div align= left >
  <img src="/Users/stephent/stphentututu/Python_case_interview/markdown_pic/Snipaste_2020-09-29_13-17-47.png" width="30%" alt="图片"/>
  <center style="font-size:14px;color:#C0C0C0"></center>
  </br>
</div>

<h3 id="Q-列举-Python2和Python3的区别"><a href="#Q-列举-Python2和Python3的区别" class="headerlink" title="Q: 列举 Python2和Python3的区别"></a>Q: 列举 Python2和Python3的区别</h3><ol>
<li>print函数:（Python3中print为一个函数，必须用括号括起来；Python2中print为class），Python 2 的 print 声明已经被 print() 函数取代了，这意味着我们必须包装我们想打印在小括号中的对象。</li>
<li>通过input()解析用户的输入：（Python3中input得到的为str；Python2的input的到的为int型，Python2的raw_input得到的为str类型）统一一下：Python3中用input，Python2中用raw_input，都输入为str</li>
</ol>
<div align= center >
  <img src="/Users/stephent/stphentututu/Python_case_interview/markdown_pic/Snipaste_2020-09-29_13-35-13.png" width="40%" alt="图片"/>
  <center style="font-size:14px;color:#C0C0C0"></center>
  </br>
</div>

<ol start="3">
<li><p>整除：Python3中/表示整除，%表示取余，//结果取整；Python2中带上小数点/表示整除，%表示取余，//结果取整</p>
<div align= left >
<img src="/Users/stephent/stphentututu/Python_case_interview/markdown_pic/Snipaste_2020-09-29_13-44-43.png" width="30%" alt="图片"/>
<img src="/Users/stephent/stphentututu/Python_case_interview/markdown_pic/Snipaste_2020-09-29_13-45-41.png" width="30%" alt="图片"/ align=center>
<center style="font-size:14px;color:#C0C0C0"></center>
</br>
<div align= right >
</li>
<li><p>range 与 xrange</p>
<p>原 : range( 0, 4 )   结果 是 列表 [0,1,2,3 ]</br><br>改为：list( range(0,4) )</br><br>原 : xrange( 0, 4 )适用于 for 循环的变量控制</br><br>改为：range(0,4)</p>
</li>
</ol>
<h3 id="Q-Python3和Python2中-int-和-long的区别"><a href="#Q-Python3和Python2中-int-和-long的区别" class="headerlink" title="Q: Python3和Python2中 int 和 long的区别"></a>Q: Python3和Python2中 int 和 long的区别</h3><p>Python2 有 int 和 long 类型。int 类型最大值不能超过 sys.maxint，而且这个最大值是平台相关的。可以通过在数字的末尾附上一个Ｌ来定义长整型，显然，它比 int 类型表示的数字范围更大。在 Python3 里，只有一种整数类型 int，大多数情况下，和 Python２中的长整型类似。</p>
<h3 id="Q-xrange和range的区别"><a href="#Q-xrange和range的区别" class="headerlink" title="Q: xrange和range的区别"></a>Q: xrange和range的区别</h3><p> <strong>range</strong> 在python2中range可以直接返回一个列表<br> <div align= left ><br>   <img src="/Users/stephent/stphentututu/Python_case_interview/markdown_pic/Snipaste_2020-09-29_14-39-19.png" width="20%" alt="图片"/><br>   <img src="/Users/stephent/stphentututu/Python_case_interview/markdown_pic/Snipaste_2020-09-29_14-40-49.png" width="30%" alt="图片"/><br>   <center style="font-size:14px;color:#C0C0C0"></center><br>   <center style="font-size:14px;color:#C0C0C0"></center><br>   </br><br> </div></p>
<p><strong>xrange</strong> 在python3中已经没有了<br><br>在python2中返回的是一个生成器，不会一下子开辟出所有的内存空间，生成一个开一个</p>
<div align= center >
  <img src="/Users/stephent/stphentututu/Python_case_interview/markdown_pic/Snipaste_2020-09-29_14-48-52.png" width="20%" alt="图片"/>
  <center style="font-size:14px;color:#C0C0C0"></center>
  </br>
</div>

<p>总结，python3弃用了xrange，但python3的range功能和python2的xrange一样，都是一个生成器</p>
<h3 id="Q-文件操作时：xreadlines和readlines的区别"><a href="#Q-文件操作时：xreadlines和readlines的区别" class="headerlink" title="Q: 文件操作时：xreadlines和readlines的区别"></a>Q: 文件操作时：xreadlines和readlines的区别</h3><p>file.readlines()是把文件的全部内容读到内存，并解析成一个list，当文件的体积很大的时候，需要占用很多内存，使用该方法是一种不明智的做法。xreadlines返回的是一个生成器类型,python3已经没有改方法.<br>readlines返回的是一个列表: <br><br><code>[‘第一行\n’, ‘第二行\n’, ‘第三行’]</code></p>
<h3 id="Q-列举布尔值为False的常见值"><a href="#Q-列举布尔值为False的常见值" class="headerlink" title="Q: 列举布尔值为False的常见值"></a>Q: 列举布尔值为False的常见值</h3><ul>
<li>0</li>
<li>[]</li>
<li>‘’</li>
<li>()</li>
<li>{}</li>
<li>False</li>
</ul>
<h3 id="Q-pass的作用"><a href="#Q-pass的作用" class="headerlink" title="Q: pass的作用"></a>Q: pass的作用</h3><p>空语句 do nothing<br><br>保证格式完整<br><br>保证语义完整<br></p>
<h3 id="Q-简述Python的深浅拷贝以及应用场景"><a href="#Q-简述Python的深浅拷贝以及应用场景" class="headerlink" title="Q: 简述Python的深浅拷贝以及应用场景"></a>Q: 简述Python的深浅拷贝以及应用场景</h3><p>深浅拷贝用法来自copy模块。</p>
<p>导入模块：import copy<br><br>浅拷贝：copy.copy<br><br>深拷贝：copy.deepcopy<br></p>
<p>对于 数字 和 字符串 而言，赋值、浅拷贝和深拷贝无意义，因为其永远指向同一个内存地址。<br><br>字面理解：浅拷贝指仅仅拷贝数据集合的第一层数据，深拷贝指拷贝数据集合的所有层。所以对于只有一层的数据集合来说深浅拷贝的意义是一样的，比如字符串，数字，还有仅仅一层的字典、列表、元组等.</p>
<p>字典（列表）的深浅拷贝</p>
<blockquote>
<p>赋值：<br></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> copy</span><br><span class="line">n1 = &#123;<span class="string">&#x27;k1&#x27;</span>:<span class="string">&#x27;wu&#x27;</span>,<span class="string">&#x27;k2&#x27;</span>:<span class="number">123</span>,<span class="string">&#x27;k3&#x27;</span>:[<span class="string">&#x27;alex&#x27;</span>,<span class="number">678</span>]&#125;</span><br><span class="line">n2 = n1</span><br></pre></td></tr></table></figure>

<div align= center >
  <img src="/Users/stephent/stphentututu/Python_case_interview/markdown_pic/Snipaste_2020-10-01_00-22-23.png" width="40%" alt="图片"/>
  <center style="font-size:14px;color:#C0C0C0"></center>
  </br>
</div>

<blockquote>
<p>浅拷贝：<br></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> copy</span><br><span class="line">n1 = &#123;<span class="string">&#x27;k1&#x27;</span>:<span class="string">&#x27;wu&#x27;</span>,<span class="string">&#x27;k2&#x27;</span>:<span class="number">123</span>,<span class="string">&#x27;k3&#x27;</span>:[<span class="string">&#x27;alex&#x27;</span>,<span class="number">678</span>]&#125;</span><br><span class="line">n3 = copy.copy(n1)</span><br></pre></td></tr></table></figure>
<div align= center >
  <img src="/Users/stephent/stphentututu/Python_case_interview/markdown_pic/Snipaste_2020-10-01_00-26-21.png" width="40%" alt="图片"/>
  <center style="font-size:14px;color:#C0C0C0"></center>
  </br>
</div>

<blockquote>
<p>深拷贝：<br></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> copy</span><br><span class="line">n1 = &#123;<span class="string">&#x27;k1&#x27;</span>:<span class="string">&#x27;wu&#x27;</span>,<span class="string">&#x27;k2&#x27;</span>:<span class="number">123</span>,<span class="string">&#x27;k3&#x27;</span>:[<span class="string">&#x27;alex&#x27;</span>,<span class="number">678</span>]&#125;</span><br><span class="line">n4 = copy.deepcopy(n1)</span><br></pre></td></tr></table></figure>
<div align= center >
  <img src="/Users/stephent/stphentututu/Python_case_interview/markdown_pic/Snipaste_2020-10-01_01-39-06.png" width="40%" alt="图片"/>
  <center style="font-size:14px;color:#C0C0C0"></center>
  </br>
</div>

<p>sum:</br>深拷贝的时候python将字典的所有数据在内存中新建了一份，所以如果你修改新的模版的时候老模版不会变。相反，在浅copy 的时候，python仅仅将最外层的内容在内存中新建了一份出来，字典第二层的列表并没有在内存中新建，所以你修改了新模版，默认模版也被修改了。</p>
<p>深浅拷贝的应用场景<br><br>比如在CMDB系统中，我们定义了一个报警模版call给所有的服务器使用，此时有一批特殊应用的服务器需要不通的报警参数，我们既不想单独新建模版来一个一个添加报警参数，又不想修改默认模版而影响其他机器的报警阈值。此时我们就需要用深拷贝来完成。示例如下：<br><br>此时的特殊模版需求是cpu报警阀值要改成75，而不影响默认模版使用</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> copy</span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认模版</span></span><br><span class="line">call = &#123;</span><br><span class="line">    <span class="string">&#x27;cpu&#x27;</span>: [<span class="number">80</span>, ],</span><br><span class="line">    <span class="string">&#x27;mem&#x27;</span>: [<span class="number">80</span>, ],</span><br><span class="line">    <span class="string">&#x27;disk&#x27;</span>: [<span class="number">80</span>, ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新模板</span></span><br><span class="line">new_call = copy.deepcopy(call)</span><br><span class="line"><span class="comment"># 修改新模版</span></span><br><span class="line">new_call[<span class="string">&#x27;cpu&#x27;</span>][<span class="number">0</span>] = <span class="number">75</span></span><br><span class="line"><span class="comment"># 查看新旧模版的值</span></span><br><span class="line">print(<span class="string">&#x27;新的模版为：%s&#x27;</span> % new_call)</span><br><span class="line">print(<span class="string">&#x27;默认模版为：%s&#x27;</span> % call)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印结果：</span></span><br><span class="line">新的模版为：&#123;<span class="string">&#x27;cpu&#x27;</span>: [<span class="number">75</span>], <span class="string">&#x27;mem&#x27;</span>: [<span class="number">80</span>], <span class="string">&#x27;disk&#x27;</span>: [<span class="number">80</span>]&#125;</span><br><span class="line">默认模版为：&#123;<span class="string">&#x27;cpu&#x27;</span>: [<span class="number">80</span>], <span class="string">&#x27;mem&#x27;</span>: [<span class="number">80</span>], <span class="string">&#x27;disk&#x27;</span>: [<span class="number">80</span>]&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#上面的代码显示我们只改了新的模版，而默认模版并没有修改，并且我们用了copy而不是单独新建模版。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意：下面的代码是能运行的</span></span><br><span class="line">a = [<span class="number">1</span>, ]</span><br><span class="line">print(a)  <span class="comment"># [1]</span></span><br></pre></td></tr></table></figure>
<p>假设我们用浅copy来做结果是这样的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> copy</span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认模版</span></span><br><span class="line">call = &#123;</span><br><span class="line">    <span class="string">&#x27;cpu&#x27;</span>: [<span class="number">80</span>, ],</span><br><span class="line">    <span class="string">&#x27;mem&#x27;</span>: [<span class="number">80</span>, ],</span><br><span class="line">    <span class="string">&#x27;disk&#x27;</span>: [<span class="number">80</span>, ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新模板</span></span><br><span class="line">new_call = copy.copy(call)</span><br><span class="line"><span class="comment"># 修改新模版</span></span><br><span class="line">new_call[<span class="string">&#x27;cpu&#x27;</span>][<span class="number">0</span>] = <span class="number">75</span></span><br><span class="line"><span class="comment"># 查看新旧模版的值</span></span><br><span class="line">print(<span class="string">&#x27;新的模版为：%s&#x27;</span> % new_call)</span><br><span class="line">print(<span class="string">&#x27;默认模版为：%s&#x27;</span> % call)</span><br><span class="line"><span class="comment"># 打印的结果：</span></span><br><span class="line"><span class="comment"># 新的模版为：&#123;&#x27;mem&#x27;: [80], &#x27;disk&#x27;: [80], &#x27;cpu&#x27;: [75]&#125;</span></span><br><span class="line"><span class="comment"># 默认模版为：&#123;&#x27;mem&#x27;: [80], &#x27;disk&#x27;: [80], &#x27;cpu&#x27;: [75]&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#默认模版和新模版都被修改了，显然这不是我们要的结果</span></span><br></pre></td></tr></table></figure>
<p>不懂得话就看这篇文章：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_34493908/article/details/81560546">https://blog.csdn.net/qq_34493908/article/details/81560546</a></p>
<h3 id="Q-理解python对象引用计数，理解垃圾回收"><a href="#Q-理解python对象引用计数，理解垃圾回收" class="headerlink" title="Q: 理解python对象引用计数，理解垃圾回收"></a>Q: 理解python对象引用计数，理解垃圾回收</h3><p>1、引用计数<br><br>查看引用计数<br><br>当一个数据没有变量指向它时，这个数据的引用计数就变成了0，Python会销毁这种对象，这就是GC(垃圾回收)可以通过sys.getrefcount()方法查看一个数据的引用数量。<br><br>下面这段代码，一定要在Python交互式解释器下执行，因为在其他环境下，会做优化处理，导致实际结果与理论结果不符。<br></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Python <span class="number">3.7</span><span class="number">.6</span> (default, Jan  <span class="number">8</span> <span class="number">2020</span>, <span class="number">13</span>:<span class="number">42</span>:<span class="number">34</span>)</span><br><span class="line">[Clang <span class="number">4.0</span><span class="number">.1</span> (tags/RELEASE_401/final)] :: Anaconda, Inc. on darwin</span><br><span class="line">Type <span class="string">&quot;help&quot;</span>, <span class="string">&quot;copyright&quot;</span>, <span class="string">&quot;credits&quot;</span> <span class="keyword">or</span> <span class="string">&quot;license&quot;</span> <span class="keyword">for</span> more information.</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> sys</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">343</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = a</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.getrefcount(a)</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>

<ul>
<li>a 指向了343，引用次数加1</li>
<li>b 也指向了343，引用次数加1</li>
<li>a 作为实参传入 getrefcount() 函数中，会进行一次参数复制，引用次数加1</li>
</ul>
<p>所以最终343的引用数量是3</p>
<p>2、垃圾回收<br><br>当对象的引用计数为0时，GC（garbage collection）会调用这个对象的__del__方法，将其回收，将其回收，因此，可以通过重载这个方法来观察垃圾回收的过程</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pyobj</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__del__</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;对象被销毁&#x27;</span>)  <span class="comment"># 重载del方法</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">obj = Pyobj()</span><br><span class="line">obj = <span class="number">6</span>  <span class="comment"># 让这个变量obj指向其他对象</span></span><br><span class="line">print(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>当 obj = 6 这行代码被执行时，__del__方法会被执行（因为对象的引用计数降为了0）。<br></p>
<p>输出结果:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">对象被销毁</span><br><span class="line">2</span><br></pre></td></tr></table></figure>
<p>图解:</p>
<div align= center >
  <img src="/Users/stephent/stphentututu/Python_case_interview/markdown_pic/Snipaste_2020-10-01_21-58-22.png" width="60%" alt="图片"/>
  <center style="font-size:14px;color:#C0C0C0"></center>
  </br>
</div>

<div align= center >
  <img src="/Users/stephent/stphentututu/Python_case_interview/markdown_pic/Snipaste_2020-10-01_22-00-37.png" width="60%" alt="图片"/>
  <center style="font-size:14px;color:#C0C0C0"></center>
  </br>
</div>

<h3 id="Q-Python的垃圾回收机制"><a href="#Q-Python的垃圾回收机制" class="headerlink" title="Q: Python的垃圾回收机制"></a>Q: Python的垃圾回收机制</h3><p>Python的垃圾回收机制，以引用计数为主，标记清除和分代回收为辅</p>
<div align= center >
  <img src="/Users/stephent/stphentututu/Python_case_interview/markdown_pic/Snipaste_2020-10-01_22-05-04.png" width="40%" alt="图片"/>
  <center style="font-size:14px;color:#C0C0C0"></center>
  </br>
</div>

<p>1、引用计数<br><br>Python对象的核心是一个结构体</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">object</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> ob_refcnt;</span><br><span class="line">    struct_typeobject *ob_type;</span><br><span class="line">&#125; PyObject;</span><br></pre></td></tr></table></figure>
<p>不懂结构体没关系，你只需要知道ob_refcnt记录了对象的引用次数就好了。当一个对象有新的引用时，ob_refcnt加1，引用它的对象被删除时，ob_refcnt减1，当 ob_refcnt=0 时，这个对象的生命就结束了，这时，垃圾回收机制就会启动将这个对象回收。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pyobj</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__del__</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;对象被销毁&#x27;</span>)  <span class="comment"># 重载del方法</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">obj = Pyobj()</span><br><span class="line">obj = <span class="number">6</span>  <span class="comment"># 让这个变量obj指向其他对象</span></span><br><span class="line">print(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>当 obj = 6 这行代码被执行时，__del__方法会被执行（因为对象的引用计数降为了0）。<br></p>
<p>输出结果:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">对象被销毁</span><br><span class="line">2</span><br></pre></td></tr></table></figure>

<p><strong>引用计数的优点</strong></p>
<ul>
<li>简单</li>
<li>时效性高，只要引用计数为0，对象就会被销毁，内存被释放，回收内存的时间平摊到了平时，有些编程语言会在某一个点进行回收，所以这样垃圾内存就会有一定的累积</li>
</ul>
<p><strong>引用计数的缺点</strong></p>
<ul>
<li>为了维护引用计数消(即 ob_refcnt)耗了很对资源</li>
<li>循环引用，循环引用导致内存泄漏，列如下面的代码</li>
</ul>
<p>下面是一个循环引用的例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">list1 = []</span><br><span class="line">list2 = []</span><br><span class="line">list1.append(list2)</span><br><span class="line">list2.append(list1)</span><br></pre></td></tr></table></figure>
<p>两个列表互相引用，那么list1和list2的引用计数永远大于0，除非手动操作，他们不可能被GC回收，但如果你手动将其释放回收，那么GC机制岂不是形同虚设？针对这种情况，Python引入了标记清除和分代回收机制作为补充。</p>
<p>2、标记清除<br><br>引用计数，并不能解决所有的问题，一旦出现了循环引用，那么，这些对象的引用次数永远都是大于0的，但是这些对象都是不可用的垃圾数据。下面的代码展示了一种循环引用的情况。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gc</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DictA</span>(<span class="params"><span class="built_in">dict</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__del__</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;DictA对象被销毁&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DictB</span>(<span class="params"><span class="built_in">dict</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__del__</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;DictB对象被销毁&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>为了便于观察循环引用导致的内存泄漏问题，我定义了两个类，DictA 和 DictB 两个类，他们均继承了字典类，并且重载字典类的__del__方法。</p>
<p>下面的代码，演示<strong>没有循环引用的情况</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a = DictA()</span><br><span class="line">b = DictB()</span><br><span class="line"></span><br><span class="line">a = <span class="number">1</span></span><br><span class="line">b = <span class="number">1</span></span><br><span class="line">print(<span class="string">&#x27;ok&#x27;</span>)</span><br><span class="line"><span class="comment"># 创建一个变量，然后让这个变量指向一个新的数值</span></span><br></pre></td></tr></table></figure>
<p>a = 1 这样的代码被执行时，变量a指向了内存中的1， 那么原来所指向的那个字典对象（即 DictA()）的引用计数就变成了0，因此对象被销毁，程序运行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DictA对象被销毁</span><br><span class="line">DictB对象被销毁</span><br><span class="line">ok</span><br></pre></td></tr></table></figure>
<p>图解：</p>
<div align= center >
  <img src="/Users/stephent/stphentututu/Python_case_interview/markdown_pic/Snipaste_2020-10-01_22-51-51.png" width="40%" alt="图片"/>
  <center style="font-size:14px;color:#C0C0C0"></center>
  </br>
</div>

<div align= center >
  <img src="/Users/stephent/stphentututu/Python_case_interview/markdown_pic/Snipaste_2020-10-01_22-53-50.png" width="40%" alt="图片"/>
  <center style="font-size:14px;color:#C0C0C0"></center>
  </br>
</div>

<div align= center >
  <img src="/Users/stephent/stphentututu/Python_case_interview/markdown_pic/Snipaste_2020-10-01_22-54-44.png" width="40%" alt="图片"/>
  <center style="font-size:14px;color:#C0C0C0"></center>
  </br>
</div>

<p>下面的代码，演示有<strong>循环引用的情况</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">a = DictA()</span><br><span class="line">b = DictB()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在字典类中插入key value，key可以随便写，value不行</span></span><br><span class="line">a[<span class="string">&#x27;qwe&#x27;</span>] = b  <span class="comment"># 循环引用</span></span><br><span class="line">b[<span class="string">&#x27;asd&#x27;</span>] = a</span><br><span class="line"></span><br><span class="line">a = <span class="number">1</span></span><br><span class="line">b = <span class="number">1</span></span><br><span class="line">print(<span class="string">&#x27;ok&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ok</span><br><span class="line">DictA对象被销毁</span><br><span class="line">DictB对象被销毁</span><br></pre></td></tr></table></figure>
<p>由于存在循环引用，因此，内存中DictA对象的引用计数是2，当 a = 1 被执行时，引用计数减少为1， 但仍然大于0，不会被回收，DcitB的对象同样如此，下图是存在循环引用时的内存对象示意图。</p>
<div align= center >
  <img src="/Users/stephent/stphentututu/Python_case_interview/markdown_pic/Snipaste_2020-10-01_23-10-40.png" width="40%" alt="图片"/>
  <center style="font-size:14px;color:#C0C0C0"></center>
  </br>
</div>

<div align= center >
  <img src="/Users/stephent/stphentututu/Python_case_interview/markdown_pic/Snipaste_2020-10-01_23-12-23.png" width="40%" alt="图片"/>
  <center style="font-size:14px;color:#C0C0C0"></center>
  </br>
</div>

<p>对象销毁的信息是在print(‘ok’)以后才被输出的，说明，当 a = 1 被执行时，原来a所指向的那个字典对象并没有被销毁。</p>
<p><strong>标记清除的原理</strong><br>标记清除可以处理这种循环引用的情况，它分为两个阶段</p>
<p>– 第1阶段，标记阶段<br><br>GC会把所有的活动对象打上标记，这些活动的对象就如同一个点，他们之间的引用关系构成边，最终点和边构成了一个有向图，如下图所示</p>
<div align= center >
  <img src="/Users/stephent/stphentututu/Python_case_interview/markdown_pic/Snipaste_2020-10-01_23-19-56.png" width="40%" alt="图片"/>
  <center style="font-size:14px;color:#C0C0C0"></center>
  </br>
</div>

<p>– 第2阶段，搜索清除阶段<br><br>从根对象（root）出发，沿着有向边遍历整个图，不可达的对象就是需要清理垃圾对象。这个根对象就是全局对象，调用栈，寄存器。</p>
<p>从上图中，从 root 出发后，可以达到 1 2 3 4，而 5，6，7均不能到达，其中6 和7 互相作用，这3 个对象都会被回收。</p>
<p>3、分代回收 <br><br>分代回建立标记清除的基础之上，是一种以空间换时间的操作方式。标记清除可以回收循环引用的垃圾，但是，回收的频次是需要控制的，如果时时刻刻做标记清除，可以想象，Python的程序会慢成什么样子。</p>
<p>分代回收，根据内存中对象的存活时间将它们分成3代，新生的对象放入0代，如果一个对象能在第0代的垃圾回收过程中存活下来，GC就会将其放入1代中，如果1代里的对象在第1代的垃圾回收过程中存活下来，就会进入到2代。</p>
<p><strong>分代回收的触发机制</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gc</span><br><span class="line">print(gc.get_threshold())</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(700, 10, 10)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>理解结果中的这三个参数</p>
</blockquote>
<ul>
<li>当分配对象的个数减去释放对象的个数的差值大于700时，就会产生一次0代回收</li>
<li>10 次0 代回收会导致一次 1 代 回收</li>
<li>10 次1 代回收会导致一次 2 代 回收</li>
</ul>
<p>对于第0 代的对象来说，他们很有可能就被使用了一次，因此需要经常被回收。</p>
<p>经过一轮一轮的回收后，能够存活着成为第 2 低的对象，必然是那些使用频繁的对象，而且他们已经存活很久的时间了，大概率的，还会存活很久，因此，2代回收的就不那么频繁。</p>
<p>可以通过设置这三个阈值，来改变分代回收的触发条件</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gc</span><br><span class="line"></span><br><span class="line">gc.set_threshold(<span class="number">600</span>, <span class="number">10</span>, <span class="number">5</span>)</span><br><span class="line">print(gc.get_threshold())  <span class="comment"># (600, 10, 5)</span></span><br></pre></td></tr></table></figure>
<p><strong>经过上面的设置，0代和2代的回收会更加频繁</strong></p>
<h3 id="Q-Python的可变类型和不可变类型"><a href="#Q-Python的可变类型和不可变类型" class="headerlink" title="Q: Python的可变类型和不可变类型"></a>Q: Python的可变类型和不可变类型</h3><p>不可变数据类型：当该数据类型的对应变量的值发生了改变，那么它对应的内存地址也会发生改变，对于这种数据类型，就称不可变数据类型。</p>
<p>可变数据类型：当该数据类型的对应变量的值发生了改变，那么它对应的内存地址不发生改变，对于这种数据类型，就称可变数据类型。</p>
<p>总结：不可变数据类型更改后地址发生改变，可变数据类型更改地址不发生改变</p>
<p>1、整型</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br><span class="line">print(<span class="built_in">id</span>(a), <span class="built_in">type</span>(a))</span><br><span class="line">a = <span class="number">2</span></span><br><span class="line">print(<span class="built_in">id</span>(a), <span class="built_in">type</span>(a))</span><br><span class="line"></span><br><span class="line"><span class="number">4546691760</span> &lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">int</span>&#x27;&gt;</span></span><br><span class="line"><span class="class">4546691792 &lt;<span class="title">class</span> &#x27;<span class="title">int</span>&#x27;&gt;</span></span><br></pre></td></tr></table></figure>
<p>当数据发生改变后，变量的内存地址发生了改变，那么整型就是不可变数据类型。</p>
<p>2、字符串</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">b = <span class="string">&#x27;stephen&#x27;</span></span><br><span class="line">print(<span class="built_in">id</span>(b),<span class="built_in">type</span>(b))</span><br><span class="line">b = <span class="string">&#x27;stephen1995&#x27;</span></span><br><span class="line">print(<span class="built_in">id</span>(b),<span class="built_in">type</span>(b))</span><br><span class="line"></span><br><span class="line"><span class="number">140553675532144</span> &lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">str</span>&#x27;&gt;</span></span><br><span class="line"><span class="class">140553675598512 &lt;<span class="title">class</span> &#x27;<span class="title">str</span>&#x27;&gt;</span></span><br></pre></td></tr></table></figure>
<p>当数据发生改变后，变量的内存地址发生了改变，那么字符串就是不可变数据类型。</p>
<p>3、元组<br>元组被称为只读列表，即数据可以被查询，但不能被修改,但是我们可以在元组的元素中存放一个列表，通过更改列表的值来查看元组是属于可变还是不可变。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">c1 = [<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>]</span><br><span class="line">c = (<span class="number">1</span>, <span class="number">2</span>, c1)</span><br><span class="line">print(c, <span class="built_in">id</span>(c), <span class="built_in">type</span>(c), <span class="built_in">id</span>(c1))</span><br><span class="line">c1[<span class="number">1</span>] = <span class="string">&#x27;djx&#x27;</span></span><br><span class="line">print(c, <span class="built_in">id</span>(c), <span class="built_in">type</span>(c), <span class="built_in">id</span>(c1))</span><br><span class="line"></span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, [<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>]) <span class="number">140280040628864</span> &lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">tuple</span>&#x27;&gt; 140280038236640</span></span><br><span class="line"><span class="class">(<span class="params"><span class="number">1</span>, <span class="number">2</span>, [<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;djx&#x27;</span>]</span>) 140280040628864 &lt;<span class="title">class</span> &#x27;<span class="title">tuple</span>&#x27;&gt; 140280038236640</span></span><br></pre></td></tr></table></figure>
<p>虽然在列表中更改了值，但是列表的地址没有改变，列表在元组中的地址的值没有改变，所以也就意味着元组没有发生变化。我们就可以认为元组是不可变数据类型，因为元组是不可变</p>
<p>4、集合<br><br>集合我们常用来进行去重和关系运算，集合是无序的。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">s = &#123;<span class="number">1</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;34&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="number">1</span>&#125;</span><br><span class="line">print(s, <span class="built_in">type</span>(s), <span class="built_in">id</span>(s))</span><br><span class="line">s.add(<span class="string">&#x27;stephen&#x27;</span>)</span><br><span class="line">print(s, <span class="built_in">type</span>(s), <span class="built_in">id</span>(s))</span><br><span class="line"></span><br><span class="line">&#123;<span class="number">1</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;34&#x27;</span>&#125; &lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">set</span>&#x27;&gt; 140609711737504</span></span><br><span class="line">&#123;1, &#x27;stephen&#x27;, &#x27;d&#x27;, &#x27;34&#x27;, &#x27;1&#x27;&#125; &lt;class &#x27;set&#x27;&gt; 140609711737504</span><br></pre></td></tr></table></figure>
<p>虽然集合数据发生改变，但是内存地址没有发生了改变，那么集合就是可变数据类型。</p>
<p>5、列表<br><br>它是以[]括起来，每个元素以逗号隔开，而且它里面可以存放各种数据类型。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span> = [<span class="number">1</span>, <span class="string">&#x27;q&#x27;</span>, <span class="string">&#x27;qwer&#x27;</span>, <span class="literal">True</span>]</span><br><span class="line">print(<span class="built_in">list</span>, <span class="built_in">type</span>(<span class="built_in">list</span>), <span class="built_in">id</span>(<span class="built_in">list</span>))</span><br><span class="line"><span class="built_in">list</span>.append(<span class="string">&#x27;stephen&#x27;</span>)</span><br><span class="line">print(<span class="built_in">list</span>, <span class="built_in">type</span>(<span class="built_in">list</span>), <span class="built_in">id</span>(<span class="built_in">list</span>))</span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>, <span class="string">&#x27;q&#x27;</span>, <span class="string">&#x27;qwer&#x27;</span>, <span class="literal">True</span>] &lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">list</span>&#x27;&gt; 140620288565728</span></span><br><span class="line">[1, &#x27;q&#x27;, &#x27;qwer&#x27;, True, &#x27;stephen&#x27;] &lt;class &#x27;list&#x27;&gt; 140620288565728</span><br></pre></td></tr></table></figure>
<p>虽然列表数据发生改变，但是内存地址没有发生了改变，那么列表就是可变数据类型。</p>
<p>6、字典<br><br>字典是python中唯一的映射类型，采用键值对（key-value）的形式存储数据。<br><br>python对key进行哈希函数运算，根据计算的结果决定value的存储地址，所以字典是无序存储的。但是在3.6版本后，字典开始是有序的，这是新的版本特征。<br><br>字典的key值可以是整型，字符串，元组，但是不可以是列表，集合，字典。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">tup = (<span class="number">1</span>,)</span><br><span class="line"><span class="comment"># dic = &#123;1: 2&#125;</span></span><br><span class="line">d = &#123;tup: <span class="number">1</span>, <span class="string">&#x27;key2&#x27;</span>: <span class="string">&#x27;stephen&#x27;</span>, <span class="string">&#x27;key3&#x27;</span>: <span class="string">&#x27;li&#x27;</span>&#125;</span><br><span class="line">print(d, <span class="built_in">type</span>(d), <span class="built_in">id</span>(d))</span><br><span class="line">d[<span class="string">&#x27;key4&#x27;</span>] = <span class="string">&#x27;haha&#x27;</span></span><br><span class="line">print(d, <span class="built_in">type</span>(d), <span class="built_in">id</span>(d))</span><br><span class="line"></span><br><span class="line">&#123;<span class="number">1</span>: <span class="number">1</span>, <span class="string">&#x27;key2&#x27;</span>: <span class="string">&#x27;stephen&#x27;</span>, <span class="string">&#x27;key3&#x27;</span>: <span class="string">&#x27;li&#x27;</span>&#125; &lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">dict</span>&#x27;&gt; 140467490992608</span></span><br><span class="line">&#123;1: 1, &#x27;key2&#x27;: &#x27;stephen&#x27;, &#x27;key3&#x27;: &#x27;li&#x27;, &#x27;key4&#x27;: &#x27;haha&#x27;&#125; &lt;class &#x27;dict&#x27;&gt; 140467490992608</span><br></pre></td></tr></table></figure>
<p>虽然字典数据发生改变，但是内存地址没有发生了改变，那么字典就是可变数据类型。</p>
<p>Summary:<br></p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>可变/不可变</th>
</tr>
</thead>
<tbody><tr>
<td>整型</td>
<td>不可变</td>
</tr>
<tr>
<td>字符串</td>
<td>不可变</td>
</tr>
<tr>
<td>列表</td>
<td>可变</td>
</tr>
<tr>
<td>集合</td>
<td>可变</td>
</tr>
<tr>
<td>字典</td>
<td>可变</td>
</tr>
</tbody></table>
</br>
</br>
</br>
</br>
</br>
</br>
</br>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/09/28/Python%20%E9%9D%A2%E8%AF%95%E9%A2%98/" data-id="ckgeqzjdn00032axkfbhja4dw" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2020/10/18/hello-world/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          Hello World
        
      </div>
    </a>
  
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">October 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">September 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/10/18/%E5%8F%91%E5%B8%83%E7%AC%AC%E4%B8%80%E7%AF%87%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/">发布第一篇个人博客</a>
          </li>
        
          <li>
            <a href="/2020/10/18/tuchun/">tuchun</a>
          </li>
        
          <li>
            <a href="/2020/10/18/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/2020/09/28/Python%20%E9%9D%A2%E8%AF%95%E9%A2%98/">Python 面试题</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>